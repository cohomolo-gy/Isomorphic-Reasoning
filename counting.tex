\documentclass[tikz]{beamer}

\usepackage{listings}
\usepackage{eucal,mathrsfs}
\usepackage{tikz-cd}
\usepackage{amsfonts}
\usepackage{enumerate}
  
\usetheme{Darmstadt}
\colorlet{shadecolor}{gray!15}

\newcommand{\propnumber}{} % initialize
\newtheorem*{prop}{Proposition \propnumber}
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]

\newenvironment{propc}[1]
  {\renewcommand{\propnumber}{#1}%
   \begin{shaded}\begin{prop}}
  {\end{prop}\end{shaded}}

\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\homf}[2]{[\cat{#1}, \cat{#2}]}

\newenvironment{haskell}{\begin{lstlisting}[language=haskell]}{\end{lstlisting}}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

\title{Isomorphic Reasoning: Counting Polymorphic Type Inhabitants}
\author{Emily Pillmore, Alexander Konovalov}
\date{May 2019}

\begin{document}
\section{Counting Type Inhabitants}

\begin{frame}

We can finally begin counting! Let's start with some preliminary remarks.
\end{frame}

\begin{frame}

We will denote $\ldots$

\begin{itemize}
	\item the initial object  \textbf{undefined} as $0$
	\item the terminal object $()$ as $1$
	\item functions $a \to b$ as $b^a$
	\item tuples $(a, b)$ as $a * b$
	\item co-products \textbf{Either a b} as $a + b$
\end{itemize}

Additionally, we will denote covariant focus by the term \textbf{forall} or $\forall$ interchangeably, and contravariant focus by explicitly stating \textbf{exists} or $\exists$.
\end{frame}

\begin{frame}
Why do we even care to count?
\end{frame}

\begin{frame}{Inhabitants}
An inhabitant of a type $T$ is any expression $e : T$ of type $T$. It is of importance to be able to ascertain the number of such inhabitants for a variety of types in pure functional languages since:

\begin{itemize}
	\item Knowing that a complicated polymorphic type has only a small number of inhabitants (e.g.$ \forall a. a \to a$ having only one inhabitant) means that we can partially or fully understand its behavior based on the type alone without referring to a particular implementation.
	\item Knowing that a $T$ has only one inhabitant $e : T$ allows us to simplify any complicated \textit{complicated\_expression} $ : T$ and replace it with $e : T$.
	\item If we can find the number of inhabitants, we can likely also enumerate them.
	\item Proving that a type P has inhabitants is equivalent to proving the corresponding theorem P via the Curry-Howard-Lambek Correspondence.
	\item If we can automatically prove that a type has no inhabitants, we can save the developer some time.
	\item If we have a known most-efficient-representation of an expression which can be reached transitively via a sequence of isomorphisms, then it would be a boon to optimizing programs, as a compiler could know for certain that <most efficient representation> would not affect the operational semantics of the program.
\end{itemize}
\end{frame}
	
\begin{frame}
Q: There might be some confusion regarding what exactly we mean by “inhabitants”, e.g. are $1 + 1$ and $2$ different inhabitants of type $Int$?

\end{frame}

\begin{frame}
Q: There might be some confusion regarding what exactly we mean by “inhabitants”, e.g. are $1 + 1$ and $2$ different inhabitants of type $Int$?

\newline
A: We consider isomorphism classes, and modulo isomorphisms, they are the same. This is a rather deep topic, so for now we will assume no edge cases, and that if two seemingly equivalent witnesses of type $a$ are not isomorphic, then there exists some sub-object classifier of $f: a \to Bool$ which distinguishes the two.
\end{frame}

\begin{frame}{Exercise}

\begin{block}{}
Exercise: How can we show that
\begin{center}
	\begin{equation*}
		\text{Either $() ()$} \cong \text{Bool} \cong \mathbf{2}?
	\end{equation*}
\end{center}
\end{block}

\end{frame}

\begin{frame}[fragile]
We can certainly show it explicitly: 

\begin{block}{}

\begin{center}
	\begin{lstlisting}[language=Haskell]
		to :: Either () () -> Bool
		to (Right ()) = True
		to (Left ())  = False

		from :: Bool -> Either () ()
		from True = Right ()
		from False = Left ()
	\end{lstlisting}
\end{center}
\end{block}
\end{frame}

\end{document}

\end{document}